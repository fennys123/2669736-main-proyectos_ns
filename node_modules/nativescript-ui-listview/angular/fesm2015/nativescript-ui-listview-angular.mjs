import { ObservableArray, isIOS, LayoutBase } from '@nativescript/core';
import * as i0 from '@angular/core';
import { ElementRef, EventEmitter, IterableDiffers, NgZone, TemplateRef, ViewContainerRef, Component, ChangeDetectionStrategy, Inject, ViewChild, ContentChild, Output, Input, HostListener, Directive, Host, NgModule, NO_ERRORS_SCHEMA } from '@angular/core';
import * as i1 from '@nativescript/angular';
import { DetachedLoader, NativeScriptRendererFactory, extractSingleViewRecursive, registerElement } from '@nativescript/angular';
import { ListViewLinearLayout, ListViewViewType, NG_VIEW, RadListView, ListViewGridLayout, ListViewStaggeredLayout, ReorderHandle } from 'nativescript-ui-listview';

function isListLikeIterable(obj) {
    if (!isJsObject(obj))
        return false;
    return (Array.isArray(obj) ||
        (!(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
            Symbol.iterator in obj)); // JS Iterable have a Symbol.iterator prop
}
function isJsObject(o) {
    return o !== null && (typeof o === 'function' || typeof o === 'object');
}
class ListItemContext extends ElementRef {
    constructor($implicit, item, index, even, odd, category) {
        super(item);
        this.$implicit = $implicit;
        this.item = item;
        this.index = index;
        this.even = even;
        this.odd = odd;
        this.category = category;
    }
}
class RadListViewComponent {
    constructor(_elementRef, _iterableDiffers, _renderer, _ngZone) {
        this._elementRef = _elementRef;
        this._iterableDiffers = _iterableDiffers;
        this._renderer = _renderer;
        this._ngZone = _ngZone;
        this.setupItemView = new EventEmitter();
        this.autoReuseViews = false;
        this.changeAnimationsEnabled = true;
        this.viewPool = new Map();
        this.viewToTemplate = new WeakMap();
        this.viewToLoader = new WeakMap();
        this._listView = _elementRef.nativeElement;
        this._loaders = [];
        // We should consider setting this default value in the RadListView constructor.
        this._listView.listViewLayout = new ListViewLinearLayout();
        const component = this;
        this._listView.itemViewDisposer = () => {
            if (this.loader) {
                this.loader.clear();
            }
        };
        this._listView.nativeScriptViewAdded = (parent, child) => {
            // Consider exposing this in nativescript-angular as public API
            this._renderer.viewUtil.insertChild(parent, child);
        };
        this._listView.itemViewLoader = (viewType) => {
            return this._ngZone.run(() => {
                switch (viewType) {
                    case ListViewViewType.ItemView:
                        if (component._itemTemplate && this.loader) {
                            // this.loader.injector.get(ChangeDetectorRef).detach();
                            const typedView = this.getOrCreate(this._itemTemplate);
                            return typedView;
                        }
                        break;
                    case ListViewViewType.ItemSwipeView:
                        if (component._itemSwipeTemplate && this.loader) {
                            const nativeItem = this.loader.createEmbeddedView(component._itemSwipeTemplate, new ListItemContext(), 0);
                            const typedView = getItemViewRoot(nativeItem);
                            typedView[NG_VIEW] = nativeItem;
                            return typedView;
                        }
                        break;
                    case ListViewViewType.LoadOnDemandView:
                        if (component._loadOnDemandTemplate && this.loader) {
                            const viewRef = this.loader.createEmbeddedView(component._loadOnDemandTemplate, new ListItemContext(), 0);
                            this.detectChangesOnChild(viewRef, -1);
                            const nativeView = getItemViewRoot(viewRef);
                            nativeView[NG_VIEW] = viewRef;
                            return nativeView;
                        }
                        break;
                    case ListViewViewType.HeaderView:
                        if (component._headerTemplate && this.loader) {
                            const viewRef = this.loader.createEmbeddedView(component._headerTemplate, new ListItemContext(), 0);
                            this.detectChangesOnChild(viewRef, -1);
                            const nativeView = getItemViewRoot(viewRef);
                            nativeView[NG_VIEW] = viewRef;
                            return nativeView;
                        }
                        break;
                    case ListViewViewType.GroupView:
                        if (!this._listView.groupingFunction && this._listView._hasGroupingFunctionChanged) {
                            break;
                        }
                        if (component._groupTemplate && this.loader) {
                            const viewRef = this.loader.createEmbeddedView(component._groupTemplate, new ListItemContext(), 0);
                            this.detectChangesOnChild(viewRef, -1);
                            const nativeView = getItemViewRoot(viewRef);
                            nativeView[NG_VIEW] = viewRef;
                            return nativeView;
                        }
                        break;
                    case ListViewViewType.FooterView:
                        if (component._footerTemplate && this.loader) {
                            const viewRef = this.loader.createEmbeddedView(component._footerTemplate, new ListItemContext(), 0);
                            this.detectChangesOnChild(viewRef, -1);
                            const nativeView = getItemViewRoot(viewRef);
                            nativeView[NG_VIEW] = viewRef;
                            return nativeView;
                        }
                        break;
                }
            });
        };
    }
    detachedLoaderFactory() {
        const ref = this.loader.createComponent(DetachedLoader, {
            index: 0,
        });
        this.loader.detach(0);
        this._loaders.push(ref);
        return ref;
    }
    ngAfterViewInit() {
        this.setItemTemplates();
    }
    ngOnDestroy() {
        this._listView = null;
        this._loaders.forEach((l) => l.destroy());
        this._loaders = null;
        this.viewToLoader = null;
        this.viewToTemplate = null;
        this.viewPool = null;
        this._items = null;
        this._differ = null;
        this._headerTemplate = null;
        this._footerTemplate = null;
        this._itemTemplate = null;
        this._groupTemplate = null;
        this._itemSwipeTemplate = null;
        this._loadOnDemandTemplate = null;
        if (this._templateMap) {
            this._templateMap.clear();
        }
        this._templateMap = null;
    }
    get nativeElement() {
        return this._listView;
    }
    get listView() {
        return this._listView;
    }
    set loadOnDemandTemplate(value) {
        this._loadOnDemandTemplate = value;
        this._listView.refresh();
    }
    set headerTemplate(value) {
        this._headerTemplate = value;
        if (this._listView.ios) {
            this._listView.updateHeaderFooter();
        }
        else if (this._listView.android) {
            this._listView['_updateHeader']();
        }
    }
    set groupTemplate(value) {
        this._groupTemplate = value;
    }
    set footerTemplate(value) {
        this._footerTemplate = value;
        if (this._listView.ios) {
            this._listView.updateHeaderFooter();
        }
        else if (this._listView.android) {
            this._listView['_updateFooter']();
        }
    }
    set itemTemplate(value) {
        this._itemTemplate = value;
        this._listView.refresh();
    }
    set itemSwipeTemplate(value) {
        this._itemSwipeTemplate = value;
        this._listView.refresh();
    }
    set items(value) {
        this._items = value;
        let needDiffer = true;
        if (value instanceof ObservableArray) {
            needDiffer = false;
        }
        if (!this._differ) {
            if (needDiffer && isListLikeIterable(value)) {
                this._differ = this._iterableDiffers.find(this._items).create(this.trackBy || ((index, item) => item));
            }
            this._listView.items = this._items;
        }
    }
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this._items);
            if (changes) {
                const changeCounters = {
                    added: 0,
                    moved: 0,
                    removed: 0,
                    changed: 0,
                };
                [
                    { fn: changes.forEachAddedItem, key: 'added' },
                    { fn: changes.forEachMovedItem, key: 'moved' },
                    { fn: changes.forEachRemovedItem, key: 'removed' },
                    { fn: changes.forEachIdentityChange, key: 'changed' },
                ].map(({ fn, key }) => {
                    const collector = [];
                    fn.bind(changes)((record) => {
                        if (typeof record.previousIndex === 'number' && typeof record.currentIndex === 'number') {
                            collector.push(`${record.previousIndex} -> ${record.currentIndex}`);
                        }
                        else {
                            collector.push(`${record.previousIndex || record.currentIndex || 0}`);
                        }
                        changeCounters[key]++;
                    });
                    return `${key}(${collector})`;
                });
                let previousItemCount = 0;
                for (const item in this._listView.items) {
                    previousItemCount++;
                }
                let incomingItemCount = 0;
                for (const item in this._items) {
                    incomingItemCount++;
                }
                const totalReplacement = (changeCounters.added === incomingItemCount && changeCounters.removed === previousItemCount) || changeCounters.added > incomingItemCount || changeCounters.removed > previousItemCount;
                if (!totalReplacement && isIOS) {
                    const collectionView = this._listView.nativeViewProtected;
                    if (collectionView) {
                        const _listView = this._listView;
                        const _items = this._items;
                        const processUpdates = () => {
                            let nativePaths = NSMutableArray.alloc().init();
                            changes.forEachRemovedItem((record) => {
                                nativePaths.addObject(NSIndexPath.indexPathForRowInSection(record.previousIndex, 0));
                            });
                            if (nativePaths.count) {
                                collectionView.deleteItemsAtIndexPaths(nativePaths);
                            }
                            nativePaths = NSMutableArray.alloc().init();
                            changes.forEachAddedItem((item) => {
                                nativePaths.addObject(NSIndexPath.indexPathForRowInSection(item.currentIndex, 0));
                            });
                            if (nativePaths.count) {
                                collectionView.insertItemsAtIndexPaths(nativePaths);
                            }
                            nativePaths = NSMutableArray.alloc().init();
                            changes.forEachMovedItem((item) => {
                                collectionView.moveItemAtIndexPathToIndexPath(NSIndexPath.indexPathForRowInSection(item.previousIndex, 0), NSIndexPath.indexPathForRowInSection(item.currentIndex, 0));
                            });
                            nativePaths = NSMutableArray.alloc().init();
                            changes.forEachIdentityChange((item) => {
                                nativePaths.addObject(NSIndexPath.indexPathForRowInSection(item.currentIndex, 0));
                            });
                            if (nativePaths.count) {
                                collectionView.reloadItemsAtIndexPaths(nativePaths);
                            }
                            _listView.items = _items;
                        };
                        if (this.changeAnimationsEnabled) {
                            collectionView.performBatchUpdatesCompletion(processUpdates, () => { });
                        }
                        else {
                            UIView.performWithoutAnimation(() => {
                                collectionView.performBatchUpdatesCompletion(processUpdates, () => { });
                            });
                        }
                    }
                }
                else {
                    this._listView.items = this._items;
                    this._listView.refresh();
                }
            }
        }
    }
    onItemLoadingInternal(args) {
        const index = args.index;
        const currentItem = args.view.bindingContext;
        let ngView = args.view[NG_VIEW];
        // Getting angular view from original element (in cases when ProxyViewContainer
        // is used NativeScript internally wraps it in a StackLayout)
        if (!ngView && args.view instanceof LayoutBase && args.view.getChildrenCount() > 0) {
            ngView = args.view.getChildAt(0)[NG_VIEW];
        }
        if (ngView) {
            this.setupViewRef(ngView, currentItem, index);
            if (args.android) {
                // ios implements the itemReappearingInternal event so we don't reattach, just detect changes until the view is shown
                this.attachChild(ngView);
            }
            this.detectChangesOnChild(ngView, index);
        }
    }
    onItemReappearingInternal(args) {
        if (!args.view) {
            return;
        }
        let ngView = args.view[NG_VIEW];
        // Getting angular view from original element (in cases when ProxyViewContainer
        // is used NativeScript internally wraps it in a StackLayout)
        if (!ngView && args.view instanceof LayoutBase && args.view.getChildrenCount() > 0) {
            ngView = args.view.getChildAt(0)[NG_VIEW];
        }
        // console.log('reappearing', args.view);
        if (ngView) {
            this.attachChild(ngView);
        }
    }
    onItemRecyclingInternal(args) {
        if (!args.view) {
            return;
        }
        let ngView = args.view[NG_VIEW];
        // Getting angular view from original element (in cases when ProxyViewContainer
        // is used NativeScript internally wraps it in a StackLayout)
        if (!ngView && args.view instanceof LayoutBase && args.view.getChildrenCount() > 0) {
            ngView = args.view.getChildAt(0)[NG_VIEW];
        }
        // console.log('recycling', args.view);
        if (ngView) {
            ngView.detach();
        }
    }
    onItemDisposingInternal(args) {
        if (!args.view) {
            return;
        }
        if (args.view.parent) {
            args.view.parent.removeChild(args.view);
        }
        // console.log('disposing');
        let ngView = args.view[NG_VIEW];
        // console.log('disposing', args.view);
        // Getting angular view from original element (in cases when ProxyViewContainer
        // is used NativeScript internally wraps it in a StackLayout)
        if (!ngView && args.view instanceof LayoutBase && args.view.getChildrenCount() > 0) {
            ngView = args.view.getChildAt(0)[NG_VIEW];
        }
        if (ngView) {
            ngView.detach();
            this.storeViewRef(ngView);
        }
    }
    setupViewRef(viewRef, data, index) {
        const context = viewRef.context;
        context.$implicit = data;
        context.item = data;
        context.category = data ? data.category : '';
        context.index = index;
        context.even = index % 2 === 0;
        context.odd = !context.even;
        this.setupItemView.next({ view: viewRef, data: data, index: index, context: context });
        // this.detectChangesOnChild(viewRef, -1);
    }
    setLayout(layout) {
        this._listView.listViewLayout = layout;
    }
    attachChild(viewRef) {
        const loader = this.viewToLoader.get(viewRef);
        if (loader && this.loader.indexOf(loader.hostView) === -1) {
            this.loader.insert(loader.hostView, 0);
            // this.loader.insert(viewRef, 0);
        }
        viewRef.reattach();
        viewRef.markForCheck();
    }
    detectChangesOnChild(viewRef, index) {
        // Manually detect changes in child view ref
        viewRef.markForCheck();
        viewRef.detectChanges();
    }
    setItemTemplates() {
        // The itemTemplateQuery may be changed after list items are added that contain <template> inside,
        // so cache and use only the original template to avoid errors.
        this.itemTemplate = this.itemTemplateQuery;
        if (this._templateMap) {
            const templates = [];
            this._templateMap.forEach((value) => {
                templates.push(value);
            });
            this.listView.itemTemplates = templates;
        }
    }
    registerTemplate(key, template) {
        if (!this._templateMap) {
            this._templateMap = new Map();
        }
        const keyedTemplate = {
            key,
            createView: () => {
                return this.getOrCreate(template);
            },
        };
        this._templateMap.set(key, keyedTemplate);
    }
    storeViewRef(viewRef) {
        var _a;
        const templateRef = this.viewToTemplate.get(viewRef);
        if (templateRef) {
            const scrap = this.viewPool.get(templateRef);
            if (scrap) {
                if (scrap.scrapHead.size >= scrap.scrapSize) {
                    viewRef.destroy();
                    (_a = this.viewToLoader.get(viewRef)) === null || _a === void 0 ? void 0 : _a.destroy();
                }
                else {
                    scrap.scrapHead.add(viewRef);
                }
            }
        }
    }
    getOrCreate(templateRef) {
        return this._ngZone.run(() => {
            let viewRef = this.getView(templateRef);
            if (!viewRef) {
                const loader = this.detachedLoaderFactory();
                // viewRef = this.loader.createEmbeddedView(templateRef, new ListItemContext(), 0);
                viewRef = loader.instance.vc.createEmbeddedView(templateRef, new ListItemContext(), 0);
                this.viewToLoader.set(viewRef, loader);
                this.viewToTemplate.set(viewRef, templateRef);
            }
            viewRef.detach();
            const resultView = getItemViewRoot(viewRef);
            resultView[NG_VIEW] = viewRef;
            resultView.reusable = this.autoReuseViews;
            return resultView;
        });
    }
    getView(templateRef) {
        const pool = this.getViewPool(templateRef);
        while (pool.scrapHead.size > 0) {
            const viewRef = pool.scrapHead.values().next().value;
            pool.scrapHead.delete(viewRef);
            if (!viewRef.destroyed) {
                return viewRef;
            }
        }
        return null;
    }
    templatesChanges() {
        const templates = new Set([this._itemTemplate, this._groupTemplate, this._footerTemplate, this._headerTemplate, this._itemSwipeTemplate, this._loadOnDemandTemplate]);
        const toDelete = [];
        this.viewPool.forEach((v, key) => {
            if (!templates.has(key)) {
                v.scrapHead.forEach((viewRef) => {
                    viewRef.destroy();
                    this.viewToTemplate.delete(viewRef);
                });
                v.scrapHead.clear();
                toDelete.push(key);
            }
        });
        toDelete.forEach((k) => this.viewPool.delete(k));
    }
    getViewPool(templateRef) {
        if (!this.viewPool.has(templateRef)) {
            this.viewPool.set(templateRef, {
                scrapSize: this.autoReuseViews ? Infinity : 0,
                scrapHead: new Set(),
            });
        }
        return this.viewPool.get(templateRef);
    }
}
RadListViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: RadListViewComponent, deps: [{ token: ElementRef }, { token: IterableDiffers }, { token: NativeScriptRendererFactory }, { token: NgZone }], target: i0.ɵɵFactoryTarget.Component });
RadListViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.2", type: RadListViewComponent, selector: "RadListView", inputs: { autoReuseViews: "autoReuseViews", changeAnimationsEnabled: "changeAnimationsEnabled", trackBy: "trackBy", items: "items" }, outputs: { setupItemView: "setupItemView" }, host: { listeners: { "itemLoadingInternal": "onItemLoadingInternal($event)", "itemReappearingInternal": "onItemReappearingInternal($event)", "itemRecyclingInternal": "onItemRecyclingInternal($event)", "itemDisposingInternal": "onItemDisposingInternal($event)" } }, queries: [{ propertyName: "itemTemplateQuery", first: true, predicate: TemplateRef, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "loader", first: true, predicate: ["loader"], descendants: true, read: ViewContainerRef }], ngImport: i0, template: `
		<DetachedContainer>
			<ng-container #loader></ng-container>
		</DetachedContainer>
	`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: RadListViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'RadListView',
                    template: `
		<DetachedContainer>
			<ng-container #loader></ng-container>
		</DetachedContainer>
	`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () {
        return [{ type: i0.ElementRef, decorators: [{
                        type: Inject,
                        args: [ElementRef]
                    }] }, { type: i0.IterableDiffers, decorators: [{
                        type: Inject,
                        args: [IterableDiffers]
                    }] }, { type: i1.NativeScriptRendererFactory, decorators: [{
                        type: Inject,
                        args: [NativeScriptRendererFactory]
                    }] }, { type: i0.NgZone, decorators: [{
                        type: Inject,
                        args: [NgZone]
                    }] }];
    }, propDecorators: { loader: [{
                type: ViewChild,
                args: ['loader', { read: ViewContainerRef, static: false }]
            }], itemTemplateQuery: [{
                type: ContentChild,
                args: [TemplateRef, { read: TemplateRef, static: false }]
            }], setupItemView: [{
                type: Output
            }], autoReuseViews: [{
                type: Input
            }], changeAnimationsEnabled: [{
                type: Input
            }], trackBy: [{
                type: Input
            }], items: [{
                type: Input
            }], onItemLoadingInternal: [{
                type: HostListener,
                args: ['itemLoadingInternal', ['$event']]
            }], onItemReappearingInternal: [{
                type: HostListener,
                args: ['itemReappearingInternal', ['$event']]
            }], onItemRecyclingInternal: [{
                type: HostListener,
                args: ['itemRecyclingInternal', ['$event']]
            }], onItemDisposingInternal: [{
                type: HostListener,
                args: ['itemDisposingInternal', ['$event']]
            }] } });
class ListViewLinearLayoutDirective {
    constructor() { }
}
ListViewLinearLayoutDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ListViewLinearLayoutDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
ListViewLinearLayoutDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: ListViewLinearLayoutDirective, selector: "ListViewLinearLayout", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ListViewLinearLayoutDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ListViewLinearLayout',
                }]
        }], ctorParameters: function () { return []; } });
class ListViewGridLayoutDirective {
    constructor() { }
}
ListViewGridLayoutDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ListViewGridLayoutDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
ListViewGridLayoutDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: ListViewGridLayoutDirective, selector: "ListViewGridLayout", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ListViewGridLayoutDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ListViewGridLayout',
                }]
        }], ctorParameters: function () { return []; } });
class ListViewStaggeredLayoutDirective {
    constructor() { }
}
ListViewStaggeredLayoutDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ListViewStaggeredLayoutDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
ListViewStaggeredLayoutDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: ListViewStaggeredLayoutDirective, selector: "ListViewStaggeredLayout", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ListViewStaggeredLayoutDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ListViewStaggeredLayout',
                }]
        }], ctorParameters: function () { return []; } });
class ReorderHandleDirective {
    constructor() { }
}
ReorderHandleDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ReorderHandleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
ReorderHandleDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: ReorderHandleDirective, selector: "ReorderHandle", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ReorderHandleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ReorderHandle',
                }]
        }], ctorParameters: function () { return []; } });
class TKListViewHeaderDirective {
    constructor(owner, template) {
        this.owner = owner;
        this.template = template;
    }
    ngOnInit() {
        this.owner.headerTemplate = this.template;
    }
}
TKListViewHeaderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKListViewHeaderDirective, deps: [{ token: RadListViewComponent }, { token: TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
TKListViewHeaderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: TKListViewHeaderDirective, selector: "[tkListViewHeader]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKListViewHeaderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tkListViewHeader]',
                }]
        }], ctorParameters: function () {
        return [{ type: RadListViewComponent, decorators: [{
                        type: Inject,
                        args: [RadListViewComponent]
                    }] }, { type: i0.TemplateRef, decorators: [{
                        type: Inject,
                        args: [TemplateRef]
                    }] }];
    } });
class TKListViewFooterDirective {
    constructor(owner, template) {
        this.owner = owner;
        this.template = template;
    }
    ngOnInit() {
        this.owner.footerTemplate = this.template;
    }
}
TKListViewFooterDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKListViewFooterDirective, deps: [{ token: RadListViewComponent }, { token: TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
TKListViewFooterDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: TKListViewFooterDirective, selector: "[tkListViewFooter]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKListViewFooterDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tkListViewFooter]',
                }]
        }], ctorParameters: function () {
        return [{ type: RadListViewComponent, decorators: [{
                        type: Inject,
                        args: [RadListViewComponent]
                    }] }, { type: i0.TemplateRef, decorators: [{
                        type: Inject,
                        args: [TemplateRef]
                    }] }];
    } });
class TKListViewItemSwipeDirective {
    constructor(owner, template) {
        this.owner = owner;
        this.template = template;
    }
    ngOnInit() {
        this.owner.itemSwipeTemplate = this.template;
    }
}
TKListViewItemSwipeDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKListViewItemSwipeDirective, deps: [{ token: RadListViewComponent }, { token: TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
TKListViewItemSwipeDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: TKListViewItemSwipeDirective, selector: "[tkListItemSwipeTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKListViewItemSwipeDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tkListItemSwipeTemplate]',
                }]
        }], ctorParameters: function () {
        return [{ type: RadListViewComponent, decorators: [{
                        type: Inject,
                        args: [RadListViewComponent]
                    }] }, { type: i0.TemplateRef, decorators: [{
                        type: Inject,
                        args: [TemplateRef]
                    }] }];
    } });
class TKListViewItemDirective {
    constructor(owner, template) {
        this.owner = owner;
        this.template = template;
    }
    ngOnInit() {
        this.owner.itemTemplate = this.template;
    }
}
TKListViewItemDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKListViewItemDirective, deps: [{ token: RadListViewComponent }, { token: TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
TKListViewItemDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: TKListViewItemDirective, selector: "[tkListItemTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKListViewItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tkListItemTemplate]',
                }]
        }], ctorParameters: function () {
        return [{ type: RadListViewComponent, decorators: [{
                        type: Inject,
                        args: [RadListViewComponent]
                    }] }, { type: i0.TemplateRef, decorators: [{
                        type: Inject,
                        args: [TemplateRef]
                    }] }];
    } });
class TKGroupTemplateDirective {
    constructor(owner, template) {
        this.owner = owner;
        this.template = template;
    }
    ngOnInit() {
        this.owner.groupTemplate = this.template;
    }
}
TKGroupTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKGroupTemplateDirective, deps: [{ token: RadListViewComponent }, { token: TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
TKGroupTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: TKGroupTemplateDirective, selector: "[tkGroupTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKGroupTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tkGroupTemplate]',
                }]
        }], ctorParameters: function () {
        return [{ type: RadListViewComponent, decorators: [{
                        type: Inject,
                        args: [RadListViewComponent]
                    }] }, { type: i0.TemplateRef, decorators: [{
                        type: Inject,
                        args: [TemplateRef]
                    }] }];
    } });
class TKTemplateKeyDirective {
    constructor(templateRef, owner) {
        this.templateRef = templateRef;
        this.owner = owner;
    }
    set tkTemplateKey(value) {
        if (this.owner && this.templateRef) {
            this.owner.registerTemplate(value, this.templateRef);
        }
    }
}
TKTemplateKeyDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKTemplateKeyDirective, deps: [{ token: i0.TemplateRef }, { token: RadListViewComponent, host: true }], target: i0.ɵɵFactoryTarget.Directive });
TKTemplateKeyDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: TKTemplateKeyDirective, selector: "[tkTemplateKey]", inputs: { tkTemplateKey: "tkTemplateKey" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKTemplateKeyDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tkTemplateKey]',
                }]
        }], ctorParameters: function () {
        return [{ type: i0.TemplateRef }, { type: RadListViewComponent, decorators: [{
                        type: Host
                    }] }];
    }, propDecorators: { tkTemplateKey: [{
                type: Input
            }] } });
class TKListViewLoadOnDemandDirective {
    constructor(owner, template) {
        this.owner = owner;
        this.template = template;
    }
    ngOnInit() {
        this.owner.loadOnDemandTemplate = this.template;
    }
}
TKListViewLoadOnDemandDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKListViewLoadOnDemandDirective, deps: [{ token: RadListViewComponent }, { token: TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
TKListViewLoadOnDemandDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: TKListViewLoadOnDemandDirective, selector: "[tkListLoadOnDemandTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKListViewLoadOnDemandDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tkListLoadOnDemandTemplate]',
                }]
        }], ctorParameters: function () {
        return [{ type: RadListViewComponent, decorators: [{
                        type: Inject,
                        args: [RadListViewComponent]
                    }] }, { type: i0.TemplateRef, decorators: [{
                        type: Inject,
                        args: [TemplateRef]
                    }] }];
    } });
class TKListViewLayoutDirective {
    constructor(owner, _elementRef) {
        this.owner = owner;
        this._elementRef = _elementRef;
    }
    ngOnInit() {
        const layout = this._elementRef.nativeElement;
        this.owner.setLayout(layout);
    }
}
TKListViewLayoutDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKListViewLayoutDirective, deps: [{ token: RadListViewComponent }, { token: ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
TKListViewLayoutDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: TKListViewLayoutDirective, selector: "[tkListViewLayout]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TKListViewLayoutDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tkListViewLayout]',
                }]
        }], ctorParameters: function () {
        return [{ type: RadListViewComponent, decorators: [{
                        type: Inject,
                        args: [RadListViewComponent]
                    }] }, { type: i0.ElementRef, decorators: [{
                        type: Inject,
                        args: [ElementRef]
                    }] }];
    } });
function getItemViewRoot(viewRef, rootLocator = extractSingleViewRecursive) {
    return rootLocator(viewRef.rootNodes, 0);
}
const LISTVIEW_DIRECTIVES = [RadListViewComponent, TKListViewItemDirective, TKListViewItemSwipeDirective, TKListViewHeaderDirective, TKListViewFooterDirective, TKListViewLoadOnDemandDirective, TKListViewLayoutDirective, ListViewGridLayoutDirective, ListViewStaggeredLayoutDirective, ReorderHandleDirective, ListViewLinearLayoutDirective, TKTemplateKeyDirective, TKGroupTemplateDirective];
registerElement('RadListView', () => RadListView);
registerElement('ListViewLinearLayout', () => ListViewLinearLayout);
registerElement('ListViewGridLayout', () => ListViewGridLayout);
registerElement('ListViewStaggeredLayout', () => ListViewStaggeredLayout);
registerElement('ReorderHandle', () => ReorderHandle);
class NativeScriptUIListViewModule {
}
NativeScriptUIListViewModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: NativeScriptUIListViewModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NativeScriptUIListViewModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.2", ngImport: i0, type: NativeScriptUIListViewModule, declarations: [RadListViewComponent, TKListViewItemDirective, TKListViewItemSwipeDirective, TKListViewHeaderDirective, TKListViewFooterDirective, TKListViewLoadOnDemandDirective, TKListViewLayoutDirective, ListViewGridLayoutDirective, ListViewStaggeredLayoutDirective, ReorderHandleDirective, ListViewLinearLayoutDirective, TKTemplateKeyDirective, TKGroupTemplateDirective], exports: [RadListViewComponent, TKListViewItemDirective, TKListViewItemSwipeDirective, TKListViewHeaderDirective, TKListViewFooterDirective, TKListViewLoadOnDemandDirective, TKListViewLayoutDirective, ListViewGridLayoutDirective, ListViewStaggeredLayoutDirective, ReorderHandleDirective, ListViewLinearLayoutDirective, TKTemplateKeyDirective, TKGroupTemplateDirective] });
NativeScriptUIListViewModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: NativeScriptUIListViewModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: NativeScriptUIListViewModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [LISTVIEW_DIRECTIVES],
                    exports: [LISTVIEW_DIRECTIVES],
                    schemas: [NO_ERRORS_SCHEMA],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { LISTVIEW_DIRECTIVES, ListItemContext, ListViewGridLayoutDirective, ListViewLinearLayoutDirective, ListViewStaggeredLayoutDirective, NativeScriptUIListViewModule, RadListViewComponent, ReorderHandleDirective, TKGroupTemplateDirective, TKListViewFooterDirective, TKListViewHeaderDirective, TKListViewItemDirective, TKListViewItemSwipeDirective, TKListViewLayoutDirective, TKListViewLoadOnDemandDirective, TKTemplateKeyDirective, getItemViewRoot };
//# sourceMappingURL=nativescript-ui-listview-angular.mjs.map
