import { ObservableArray, Observable, isAndroid } from '@nativescript/core';
import { ListViewItemSnapMode, ListViewViewType, ListViewScrollDirection } from '..';
function extend(to, _from) {
    for (const key in _from) {
        to[key] = _from[key];
    }
    return to;
}
// Note: most of the code taken from nativescript-vue/platform/nativescript/runtime/components/list-view
// TODO: reuse code from list-view component instead of copying
const VUE_VIEW = '__vueVNodeRef__';
export default {
    props: {
        items: {
            type: [Array, Object],
            validator: val => Array.isArray(val) || val instanceof ObservableArray,
            required: true
        },
        '+alias': {
            type: String,
            default: 'item'
        },
        '+index': {
            type: String
        },
        layout: {
            type: String,
            default: 'linear'
        },
        orientation: {
            type: String,
            default: 'vertical'
        },
        gridSpanCount: {
            type: Number,
            default: 2
        },
        itemHeight: {
            type: String,
            default: 'auto'
        },
        itemTemplateSelector: {
            type: Function,
            default: undefined
        },
        itemInsertAnimation: {
            type: String,
            default: undefined
        },
        itemDeleteAnimation: {
            type: String,
            default: undefined
        }
    },
    template: `
    <NativeRadListView
      ref="listView"
      :items="items"
      height="100%"
      width="100%"
      v-bind="$attrs"
      v-on="listeners"
      @itemTap="onItemTap"
      @itemLoadingInternal="onItemLoadingInternal"
      @itemReorderStarting="onItemReorderStarting"
      @itemReordered="onItemReordered"
    >
      <slot />

      <ListViewLinearLayout
        v-if="layout === 'linear'"
        v-tkListViewLayout
        :scrollDirection="scrollDirection"
        :itemInsertAnimation="itemInsertAnimation"
        :itemDeleteAnimation="itemDeleteAnimation"
        :itemHeight="itemHeight"></ListViewLinearLayout>
      <ListViewGridLayout
        v-if="layout === 'grid'"
        v-tkListViewLayout
        :scrollDirection="scrollDirection"
        :spanCount="gridSpanCount"
        :itemInsertAnimation="itemInsertAnimation"
        :itemDeleteAnimation="itemDeleteAnimation"
        :itemHeight="itemHeight"></ListViewGridLayout>
      <ListViewStaggeredLayout
        v-if="layout === 'staggered'"
        v-tkListViewLayout
        :scrollDirection="scrollDirection"
        :itemInsertAnimation="itemInsertAnimation"
        :itemDeleteAnimation="itemDeleteAnimation"
        :itemHeight="itemHeight"
        :spanCount="gridSpanCount"></ListViewStaggeredLayout>
    </NativeRadListView>
  `,
    computed: {
        scrollDirection() {
            return this.orientation !== 'vertical' ? ListViewScrollDirection.Horizontal : ListViewScrollDirection.Vertical;
        }
    },
    watch: {
        items: {
            handler(newVal, oldVal) {
                // if oldVal is a Observable object, there is no need for watching it
                if (!(oldVal instanceof Observable)) {
                    this.$refs.listView.setAttribute('items', newVal);
                    if (this.doRefreshOnWatch) {
                        this.refresh();
                    }
                }
            },
            deep: true
        }
    },
    created() {
        // we need to remove the itemTap handler from a clone of the $listeners
        // object because we are emitting the event ourselves with added data.
        const listeners = extend({}, this.$listeners);
        delete listeners.itemTap;
        this.listeners = listeners;
        this.doRefreshOnWatch = true;
        this.getItemContext = getItemContext.bind(this);
    },
    mounted() {
        this.listView = this.$refs.listView;
        this.listView.setAttribute('itemTemplates', this.$templates.getKeyedTemplates());
        const itemTemplateSelector = this.itemTemplateSelector
            ? this.itemTemplateSelector // custom template selector if any
            : (item, index, items) => {
                let isSelected = this.listView.nativeView.isItemSelected(item);
                return this.$templates.selectorFn(this.getItemContext(item, index, isSelected));
            };
        this.listView.setAttribute('itemTemplateSelector', itemTemplateSelector);
        const availableTemplates = this.$templates.getAvailable();
        this.listView.setAttribute('itemViewLoader', itemType => {
            // TODO: add other itemTypes
            switch (itemType) {
                case ListViewViewType.HeaderView:
                    if (~availableTemplates.indexOf('header')) {
                        return this.$templates.patchTemplate('header', this.$parent);
                    }
                    break;
                case ListViewViewType.FooterView:
                    if (~availableTemplates.indexOf('footer')) {
                        return this.$templates.patchTemplate('footer', this.$parent);
                    }
                    break;
                case ListViewViewType.ItemSwipeView:
                    if (~availableTemplates.indexOf('itemswipe')) {
                        return this.$templates.patchTemplate('itemswipe', this.$parent);
                    }
                    break;
                case ListViewViewType.LoadOnDemandView:
                    if (~availableTemplates.indexOf('loadondemand')) {
                        return this.$templates.patchTemplate('loadondemand', this.$parent);
                    }
                    break;
            }
        });
    },
    methods: {
        getItem(index) {
            return typeof this.items.getItem === 'function' ? this.items.getItem(index) : this.items[index];
        },
        onItemTap(args) {
            this.$emit('itemTap', extend({ item: this.getItem(args.index) }, args));
        },
        updateGroupViewTemplate(args) {
            const templateName = 'group';
            if (~this.$templates.getAvailable().indexOf(templateName)) {
                const context = this.getItemContext(args.view.bindingContext);
                const oldVnode = args.view && args.view[VUE_VIEW];
                args.view = this.$templates.patchTemplate(templateName, context, oldVnode);
            }
        },
        updateViewTemplate(args) {
            const index = args.index;
            const items = args.object.items;
            const currentItem = args.view.bindingContext;
            const name = args.object.itemTemplateSelector(currentItem, index, items);
            let isSelected = this.listView.nativeView.isItemSelected(currentItem);
            const context = this.getItemContext(currentItem, index, isSelected);
            const oldVnode = args.view && args.view[VUE_VIEW];
            args.view = this.$templates.patchTemplate(name, context, oldVnode);
        },
        onItemLoadingInternal(args) {
            if (args.index < 0) {
                this.updateGroupViewTemplate(args);
            }
            else {
                this.updateViewTemplate(args);
            }
        },
        onItemReorderStarting(args) {
            this.doRefreshOnWatch = false;
            this.$emit('itemReorderStarted', args);
        },
        onItemReordered(args) {
            this.doRefreshOnWatch = true;
            this.$emit('itemReordered', args);
        },
        refresh() {
            this.listView.nativeView.refresh();
            // hack to force refreshing of header and footer
            // as they can have reactive data shown
            if (isAndroid) {
                this.listView.nativeView._updateHeader();
                this.listView.nativeView._updateFooter();
            }
            else {
                this.listView.nativeView.clearCellsAndUpdateHeaderFooter();
            }
        },
        scrollToIndex(index, animate = false, snapMode = ListViewItemSnapMode.Auto) {
            this.listView.nativeView.scrollToIndex(index, animate, snapMode);
        },
        notifySwipeToExecuteFinished() {
            this.listView.nativeView.notifySwipeToExecuteFinished();
        },
        getSelectedItems() {
            return this.listView.nativeView.getSelectedItems();
        }
    }
};
function getItemContext(item, index = -1, selected = false, alias = this.$props['+alias'], index_alias = this.$props['+index']) {
    return {
        [alias]: item,
        [index_alias || '$index']: index,
        $even: index % 2 === 0,
        $odd: index % 2 !== 0,
        $selected: selected
    };
}
//# sourceMappingURL=component.js.map